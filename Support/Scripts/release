#!/usr/bin/env bash
# shellcheck disable=SC1091

#  PactSwiftMockService
#
#  Created by Marko Justinek on 19/8/21.
#  Copyright ¬© 2021 Marko Justinek. All rights reserved.
#  Permission to use, copy, modify, and/or distribute this software for any
#  purpose with or without fee is hereby granted, provided that the above
#  copyright notice and this permission notice appear in all copies.
#
#  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
#  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
#  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
#  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
#  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
#  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
# release
#
# Runs the required steps to prepare and tag new version of PactSwift.
#
# Before you run this project make sure you commit the changes of the following scripts:
# 1. build_rust_dependencies
# 2. build_xcframework
#
# Notes:
# - Updates PactSwiftMockServer version number in PactSwiftVersion.swift file
# - Updates Marketing version number in Project-Shared.xcconfig file
# - Updates CHANGELOG.md
# - Commits the updates on a new 'rc/__TAG__' branch
# - Creates a tag on the last commit
# - Pushes the updates and tags to 'surpher/PactSwiftServer' repo
#
# üö®üö®üö® WARNING üö®üö®üö®
# This is still a fragile script... because I just can't find decent time to DRY it up and set it up correctly.
# If you end up editing it, just be ready for a world of pain. Or not. Either way, you have been warned.
#

set -eu
set -o pipefail

function show_help {
  echo "Usage: $0 -v {major|minor|patch} [-d description] [--dry-run]"
  echo
  echo "FLAGS"
  echo "  -v, --version         Version number to bump. Possible values are major, minor or patch."
  echo "  -d, --description     Release description."
  echo "      --dry-run         Dry run won't tag or push the changes."
  echo
  echo "Example: ./Support/release -v minor 'Bugfix Release' --dry-run"
  echo
  exit 2
}

if [[ "${CI:-false}" == true ]] ; then
  die "üö® Running on CI is not supported! Yet."
else
  echo "üëÆ‚Äç‚ôÄÔ∏è Running on a local machine..."
  RELEASE_SOURCE_DIR="${BASH_SOURCE[0]%/*}"
fi

if [ $# -lt 2 ]; then
  show_help
fi

# "import"
source "$RELEASE_SOURCE_DIR/utils.sh"
source "$RELEASE_SOURCE_DIR/CI/version_numbers.sh"
source "$RELEASE_SOURCE_DIR/Config/config.sh"

SHOULD_BUILD_RUST_BIN=${SHOULD_BUILD_RUST_BIN:-true}

DRY_RUN=false

CURRENT_BRANCH=$(git branch --show-current)
RELEASE_VERSION_PART=""
RELEASE_DESCRIPTION=""
LATEST_TAG=$(latest_tag)
CHANGE_LOG=${CHANGE_LOG:-}
REMOTE_NAME=${REMOTE_NAME:-}

####################
# Utilities
####################

function execute_cmd {
  local is_dry_run=$DRY_RUN
  if [ "$is_dry_run" = true ]; then
    echo -e "${CYAN}DRY RUN:$NOCOLOR $*"
  else
    executeCommand "$@"
  fi
}

function git_clean_orphan {
  echo -e "üõÄ Cleaning up the branch..."
  EXCEPT_FILES="${CHANGE_LOG} ${XCFRAMEWORK_LOCATION}/${XCFRAMEWORK_NAME}"
  EXCEPT_FILES="${EXCEPT_FILES// /|}"
  git ls-files | grep -v -E "$EXCEPT_FILES" | xargs git rm -f
}

function git_add_remote {
  local remote_name="$1"
  local remote_url="$2"

  # Check if the remote already exists
  if git remote get-url "$remote_name" &>/dev/null; then
    echo "üëç Remote '$remote_name' already exists."
  else
    git remote add "$remote_name" "$remote_url"
    echo "üëç Remote '$remote_name' added with URL: $remote_url"
  fi
  git fetch "$remote_name"
}

function git_check_remote_branch {
  local remote_name="$1"
  local branch_name="$2"
  git ls-remote --exit-code --heads "$remote_name" "$branch_name" >/dev/null 2>&1
  return $?
}

function git_checkout_new_release_candidate_branch {
  local remote_name="$1"
  local release_version_branch="$2"

  git fetch "$remote_name"
  git checkout --orphan "$release_version_branch"
}

function github_open_draft_pull_request {
  local version_tag="$1"
  local version_branch="$2"
  local dry_run=; dry_run=$([ "$DRY_RUN" = true ] && echo "--dry-run" || echo "")

  local GIT_COMMANDS=(
    "gh config set prompt disabled"
    "gh repo set-default $REPO_OWNER/$RELEASE_REPO_NAME"
    "cat ${TAG_MESSAGE_FILE} | gh pr create --draft --base main --head \"$version_branch\" $dry_run --title \"RC: $version_tag\" --body-file -"
    "gh repo set-default $REPO_OWNER/$DEFAULT_REPO_NAME"
    "gh config set prompt enabled"
  )

  if command -v gh &> /dev/null; then
    echo "üóÉÔ∏è Opening a draft pull request..."
    for git_command in "${GIT_COMMANDS[@]}"; do
      execute_cmd "$git_command"
    done
  else
    echo "ü§∑ 'gh' not installed."
    echo "  Open https://github.com/$REPO_OWNER/$RELEASE_REPO_NAME/pulls and open one manually..."
    echo "  See https://cli.github.com/ for more information..."
  fi
}

function update_version_file {
  local marketing_version="MARKETING_VERSION = $*"
  local config_file=$CONFIGURATION_FILE
  sed -i '' "2s/.*/$marketing_version/" "$config_file"
}

function git_create_and_push_new_version {
  local remote_name="$1"
  local remote_branch="$2"
  local release_name="$3"
  local version_tag=$VERSION_TAG
  local change_log=$CHANGE_LOG
  local xcframework=$XCFRAMEWORK_NAME
  local xcframework_dir="$XCFRAMEWORK_LOCATION"

  # Generate a release changelog for github_open_draft_pull_request function to use
  generate_release_changelog

  # [NOTE]: ######################################################################################
  # The github workflow in surpher/PactSwiftServer repo tags the release when the PR is merged!
  ################################################################################################

  local git_commands=(
    "git add ${change_log} ${xcframework_dir}/${xcframework}"
    "git commit -S -m \"$release_name\""
    "git stash -u"
    "git merge $remote_name/main --allow-unrelated-histories -X theirs -S --no-edit"
    "git stash pop"
    "git push $remote_name $remote_branch"
  )

  git_clean_orphan

  for command in "${git_commands[@]}"; do
    execute_cmd "$command"
  done
}

function cleanup {
  local git_clean="git clean -f -d -x"
  local current_branch=$CURRENT_BRANCH
  local release_version_branch=$VERSION_BRANCH

  echo "üßπ Cleanning up..."
  execute_cmd "$git_clean"

  echo "‚èÆÔ∏è Checking out $current_branch..."
  git checkout --force "$current_branch"

  echo -e "üßπ Removing $YELLOW$release_version_branch$NOCOLOR"
  git branch -D "$release_version_branch"
}

function generate_release_changelog {
  echo "üìù Generating release notes..."
  local release_notes_title=
  release_notes_title=$(head -n 1 "$CHANGE_LOG")
  local release_notes_existing=
  release_notes_existing=$(tail -n +2 "$CHANGE_LOG")

  {
    echo "$release_notes_title"
    echo
    cat "${TAG_MESSAGE_FILE}"
    echo "$release_notes_existing"
  } > "$CHANGE_LOG"
}

function update_pactswiftmockserver_changelog {
  echo "üìù Generating release notes in $CHANGE_LOG..."

  # Prepare the title for this release
  echo "## ${VERSION_TAG}" > "${TAG_MESSAGE_FILE}"
  echo >> "${TAG_MESSAGE_FILE}"

  # Get the commits from last contribution for tag message
  echo -e "ü™µ Logging '${LATEST_TAG}..HEAD'..."
  git log --pretty='* %h - %s (%an)' "${LATEST_TAG}"..HEAD >> "${TAG_MESSAGE_FILE}"

  local release_notes_title=
  release_notes_title=$(head -n 1 "$CHANGE_LOG")
  local release_notes_existing=
  release_notes_existing=$(tail -n +2 "$CHANGE_LOG")

  # Inject the new commits between title and last release
  {
    echo "$release_notes_title"
    echo
    cat "${TAG_MESSAGE_FILE}"
    echo "$release_notes_existing"
  } > "$CHANGE_LOG"
}

function git_commit_changelog_and_xcconfig {
  local marketing_version="${MARKETING_VERSION:-1}"
  echo "ü©π Committing $CHANGE_LOG to git..."
  git add "${CHANGE_LOG}" "${CONFIGURATION_FILE}"
  git commit -m "$marketing_version: Release notes"
}

function git_reset_changelog {
  echo "üîô Dropping last commit..."
  git reset --hard HEAD~1
  git status
}

function git_push_changelog {
  echo "üõ´  Pushing changes to $CURRENT_BRANCH"
  git push origin "$CURRENT_BRANCH"
}

##################
# Pre-checks
##################
while getopts ":v:d:h:-:" opt; do
  case ${opt} in
    v)
      RELEASE_VERSION_PART=$OPTARG
      ;;
    d)
      RELEASE_DESCRIPTION=$OPTARG
      ;;
    h)
      show_help
      ;;
    -)
      case "${OPTARG}" in
        dry-run)
          DRY_RUN=true
          shift
          ;;
        description)
          RELEASE_DESCRIPTION=$1
          shift 2
          ;;
        help)
          show_help
          ;;
        *)
          echo "Invalid option: --${OPTARG}" >&2
          show_help
          ;;
      esac
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      show_help
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
      show_help
      ;;
  esac
done

# Check if the version part is provided and valid
if [[ -z $RELEASE_VERSION_PART || ! "$RELEASE_VERSION_PART" =~ ^(major|minor|patch)$ ]]; then
  show_help
fi

##################
# Generate RC
##################
VERSION_TAG=$(generate_version_number "$RELEASE_VERSION_PART" "$RELEASE_DESCRIPTION")
VERSION_BRANCH="rc/${VERSION_TAG// /_}"
MARKETING_VERSION=${VERSION_TAG#v}
MARKETING_VERSION=${MARKETING_VERSION%% -*}

# Configure remote for release candidate and release version to push to
echo "üåé Adding '$REMOTE_NAME' remote..."
git_add_remote "$REMOTE_NAME" "$REMOTE_REPO_BASE/$RELEASE_REPO_NAME.git"

# Generate release notes
echo "üìù Update changelog for PactSwiftMockServer"
update_pactswiftmockserver_changelog

# Bump up the MARKETING_VERSION in xcconfig so XCFramework uses the right version
echo -e "üëä Bumping up MARKETING_VERSION in xcconfig to $MARKETING_VERSION..."
update_version_file "$MARKETING_VERSION"

# Commit changes to changelog
echo "üíÆ Commit changelog and xcconfig..."
git_commit_changelog_and_xcconfig "$MARKETING_VERSION"

# Build libpact_ffi dependencies
if [ "$SHOULD_BUILD_RUST_BIN" = true ]; then
  echo "üèóÔ∏è Building libpact_ffi binaries..."
  eval "$RELEASE_SOURCE_DIR/CI/build_rust_dependencies"
fi

# Building the XCFramework
echo "üèóÔ∏è Building the XCFramework..."
eval "$RELEASE_SOURCE_DIR/CI/build_xcframework"

# Check out the RC branch to make changes on
echo -e "üññ Checking out RC branch $YELLOW$VERSION_BRANCH$NOCOLOR..."
git_checkout_new_release_candidate_branch "$REMOTE_NAME" "$VERSION_BRANCH"

# Push RC changes
echo -e "üö¢ Releasing version v$MARKETING_VERSION..."
git_create_and_push_new_version "$REMOTE_NAME" "$VERSION_BRANCH" "$VERSION_TAG"

echo -e "üßë‚Äçüíª Open pull request for $MARKETING_VERSION..."
github_open_draft_pull_request "$MARKETING_VERSION" "$VERSION_BRANCH"

##################
# Cleanup
##################
if [ "$DRY_RUN" = true ]; then
  cmd="git clean -f -d -x && git checkout --force $CURRENT_BRANCH"
  echo "üç∏ Dry run done"
  read -r -p "Clean up what has been generated during dry run? [Y/n]" -n 1 USER_INPUT
  echo
  if [[ $USER_INPUT =~ ^[Yy]$ ]]; then
    execute_cmd "$cmd"
    git_reset_changelog
  else
    echo "üôå Leaving everything that's been generated during dry run as is..."
    echo -e "  Run $LIGHTBLUE$cmd$NOCOLOR to drop changes on this branch"
    echo -e "  Run ${LIGHTBLUE}git reset --soft HEAD~1$NOCOLOR to revert version and CHANGELOG.md changes"
    exit 0
  fi
else
  cleanup
  git_push_changelog
fi

echo "üèÅ Done."
